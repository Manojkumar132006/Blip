name: UI Config Update

on:
  push:
    branches:
      - ui-config
  pull_request:
    branches:
      - ui-config

jobs:
  update_ui_config:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 2  # Required to get the diff

      - name: Get changed files
        id: changed_files
        run: |
          # Get the list of changed files and directories
          DIFF=$(git diff --name-only HEAD^ HEAD)
          echo "::set-output name=files::$DIFF"

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pymongo

      - name: Update MongoDB (Dry Run)
        env:
          MONGO_URI: ${{ secrets.MONGO_URI }}
          UI_DATABASE_NAME: ${{ secrets.UI_DATABASE_NAME }}
        run: |
          import os
          import json
          import re
          from pymongo import MongoClient

          MONGO_URI = os.environ["MONGO_URI"]
          DATABASE_NAME = os.environ["UI_DATABASE_NAME"] or "ui"  # Assuming your database is named "ui"
          client = MongoClient(MONGO_URI)
          db = client[DATABASE_NAME]

          changed_files = os.environ["GITHUB_OUTPUT_FILES"].splitlines()

          print("Running in dry-run mode (no actual MongoDB updates)")

          for file_path in changed_files:
            if os.path.isdir(file_path):
              # Create a new collection if a directory is created
              collection_name = os.path.basename(file_path)
              if collection_name not in db.list_collection_names():
                print(f"Would create collection: {collection_name}")

            elif file_path.endswith(".json"):
              # Handle JSON files
              directory = os.path.dirname(file_path)
              collection_name = os.path.basename(directory)
              file_name = os.path.basename(file_path)

              # Extract header information from filename
              match = re.match(r"patch-v(?P<version>\d+)-location-(?P<location>\w+)-time-(?P<time>\d+)-date-(?P<date>\d+)\.json", file_name)
              if match:
                  headers = match.groupdict()
              else:
                  print(f"Skipping {file_path}: Invalid filename format")
                  continue

              try:
                with open(file_path, "r") as f:
                  json_data = json.load(f)
              except Exception as e:
                print(f"Error reading JSON file {file_path}: {e}")
                continue

              collection = db[collection_name]

              # Check if the document already exists
              existing_document = collection.find_one(headers)
              if existing_document:
                # Update the existing document
                print(f"Would update document in {collection_name}: {headers}")
              else:
                # Create a new document
                print(f"Would create document in {collection_name}: {headers}")

          client.close()